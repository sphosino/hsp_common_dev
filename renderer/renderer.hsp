#ifndef init_draw_objects
#addition "../../hsp_common/id_manager.hsp"
#addition "../../hsp_common/color_manager.hsp"
#addition "../../hsp_common/rboxf.hsp"
#include "physis.hsp"
#include "ease.hsp"
#include "static.hsp"
#module

#const DRAW_OBJECTS_MAX 3000

#const global PRIORITY_BACK   100000
#const global PRIORITY_NORMAL 200000
#const global PRIORITY_FRONT  300000

#enum global TYPE_RECT = 0
#enum global TYPE_CIRCLE
#enum global TYPE_STR
#enum global TYPE_LINE
#enum global TYPE_SPRITE

#enum global MOVE_TYPE_PHYSIS 0
#enum global MOVE_TYPE_EASE
#enum global MOVE_TYPE_STATIC

#const global LIFE_FOREVER 99999999.0

#deffunc init_draw_objects
    // オブジェクト基本情報
    dim draw_object_priority , DRAW_OBJECTS_MAX
   	ddim draw_object_life_max, DRAW_OBJECTS_MAX 
	ddim draw_object_life    , DRAW_OBJECTS_MAX
    dim draw_object_move_type, DRAW_OBJECTS_MAX
    dim draw_object_draw_type, DRAW_OBJECTS_MAX
    dim draw_object_entities , DRAW_OBJECTS_MAX
    sdim draw_object_params  , DRAW_OBJECTS_MAX
    ddim draw_object_life_elapsed, DRAW_OBJECTS_MAX
    
	newmod draw_object_id_manager, id_manager, DRAW_OBJECTS_MAX

    return

#deffunc _make_draw_object int _move_type, int _draw_type, double life, double x, double y, double w, double h, str parameters
#defcfunc make_draw_object int _move_type, int _draw_type, double life, double x, double y, double w, double h, str parameters
	if life <= 0.0{
		logmes "ライフ０以下の描画オブジェクトを作成しようとしました"
		return
	}
	if life == LIFE_FOREVER{
		logmes "永続オブジェクトを作成にゃ!"
	}

    //基本情報
    
    newid = get_new_id(draw_object_id_manager)
    
    draw_object_priority(newid) = PRIORITY_NORMAL
    draw_object_life_max(newid) = life
    draw_object_life(newid) = life
    draw_object_move_type(newid) = _move_type
    draw_object_draw_type(newid) = _draw_type
    draw_object_params(newid) = parameters
   
	switch draw_object_move_type(newid)
	case MOVE_TYPE_PHYSIS
    	draw_object_entities(newid) = make_physis_obj(x, y, w, h)
   	swbreak
   	case MOVE_TYPE_EASE
    	draw_object_entities(newid) = make_ease_obj(x, y, w, h)
    	set_easetime_all draw_object_entities(newid), life
    swbreak
    case MOVE_TYPE_STATIC
    	draw_object_entities(newid) = make_static_obj(x, y, w, h)
    swend
    return newid
    
#deffunc destroy_draw_object int id
    draw_object_life(id) = 0.0
    return
    
#deffunc destroy_draw_object_immediately int id
	; IDを解放
    release_id draw_object_id_manager, id

	; エンティティの種類に応じて削除処理
	switch draw_object_move_type(id)
	case MOVE_TYPE_PHYSIS
		del_physis_obj draw_object_entities(id)
	swbreak
	case MOVE_TYPE_EASE
		del_ease_obj draw_object_entities(id)
	swbreak
	case MOVE_TYPE_STATIC
		del_static_obj draw_object_entities(id)
	swbreak
	swend

	return
    

#deffunc draw_objects
    idnum = get_used_ids( draw_object_id_manager, ids)
    sort_list_by_priority_list ids, idnum, draw_object_priority

    repeat idnum
    
        obj_id = ids(cnt) //固有のID
        entity_id = draw_object_entities(obj_id) //描画オブジェクトの種類ごとのID

        //描画情報取得 -> (x, y, w, h, alpha) を取得

		switch draw_object_move_type(obj_id)
		
		case MOVE_TYPE_PHYSIS
			//アップデート処理
			update_physis_obj entity_id, global_draw_dt

			x = get_physis_posx (entity_id)
			y = get_physis_posy (entity_id)
			w = get_physis_sizex(entity_id)
			h = get_physis_sizey(entity_id)
			alpha = get_physis_alpha(entity_id)
		swbreak
		
		case MOVE_TYPE_EASE

			elapsed = draw_object_life_elapsed(obj_id)
			
			x = get_ease_posx (entity_id, elapsed)
			y = get_ease_posy (entity_id, elapsed)
			w = get_ease_sizex(entity_id, elapsed)
			h = get_ease_sizey(entity_id, elapsed)
			alpha = get_ease_alpha(entity_id, elapsed)
		swbreak
		
		case MOVE_TYPE_STATIC

			x = get_static_posx(entity_id)
			y = get_static_posy(entity_id)
			w = get_static_sizex(entity_id)
			h = get_static_sizey(entity_id)
			alpha = get_static_alpha(entity_id)
		swbreak
		swend

		split draw_object_params(obj_id), ",", tmp

		//描画開始
		
		switch draw_object_draw_type(obj_id)
		case TYPE_RECT
		    色を設定 int(tmp.0)
		    rect.0 = x - w / 2
		    rect.1 = y - h / 2
		    rect.2 = x + w / 2
		    rect.3 = y + h / 2
		    aboxfa rect, alpha
		swbreak

        case TYPE_CIRCLE
            色を設定 int(tmp.0)
		    rect.0 = x - w / 2
		    rect.1 = y - h / 2
		    rect.2 = x + w / 2
		    rect.3 = y + h / 2
            acircle rect, int(tmp.1)
        swbreak

        case TYPE_STR
        
		    rect.0 = x - w / 2
		    rect.1 = y - h / 2
            pos rect.0,rect.1
            font tmp.0, int(tmp.1)
            色を設定 int(tmp.3)
            mes tmp.2
        swbreak

		case TYPE_LINE
		    色を設定 int(tmp.0)
		    rect.0 = x - w / 2
		    rect.1 = y - h / 2
		    rect.2 = x + w / 2
		    rect.3 = y + h / 2
		    line rect.0,rect.1,rect.2,rect.3
		swbreak

        case TYPE_SPRITE
        
            imgid = int(tmp.0)
            sx = int(tmp.1) 
            sy = int(tmp.2)
            sw = int(tmp.3)
            sh = int(tmp.4)

			logmes strf("%d , %d,%d,%d,%d  ,  %d,%d,%d,%d",imgid ,sx,sy,sw,sh,x,y,w,h)
            color 0,0,0
            gmode 4, sw, sh, alpha
            pos x, y

            grotate imgid, sx, sy, 0, w, h
        swbreak

        swend

        //ライフ進行処理

         draw_object_life_elapsed(obj_id) += global_draw_dt

		 if draw_object_life(obj_id) < LIFE_FOREVER{
		    draw_object_life(obj_id) -= global_draw_dt
		    if draw_object_life(obj_id) <= 0.0 {
		        destroy_draw_object_immediately obj_id
		    }
		}
		
    loop
    return
    
#defcfunc get_entity_id int id
	return draw_object_entities(id)
	
#deffunc notify_dt_draw_object double d
    global_draw_dt = d
	return
	
#defcfunc is_eternal_draw_object int id
    return draw_object_life(id) >= LIFE_FOREVER

#deffunc update_params_draw_object int id, str s
    draw_object_params(id) = s
	return

#deffunc update_priority_draw_object int id, int _priority
	draw_object_priority(id) = _priority
	return
	
//ライフ操作系
#deffunc reset_life_draw_object int id
    draw_object_life(id) = draw_object_max_life(id)
    draw_object_life_elapsed(id) = 0.
	return

#deffunc extend_life_draw_object int id, double extra
    if draw_object_life(id) < LIFE_FOREVER {
        draw_object_life(id) += extra
        draw_object_life(id) = limitf(draw_object_life(id), 0.0, draw_object_max_life(id))
    }
	return


#global
init_draw_objects


#module
#deffunc sort_list_by_priority_list array a, int a_num, array b
    if a_num <= 1 : return  // 要素数が1以下ならソート不要

	;insertion_sort_range a, 0, a_num-1, b: return
	
    // 作業用配列を準備
    dim temp, a_num
	
	block_size = 12  // 初期ブロックサイズ

	ss = 0
	while ss < a_num - 1
		insertion_sort_range a, ss, limit(ss + block_size - 1,, a_num - 1), b
		ss += block_size
	wend
    while block_size < a_num
        start = 0  // ブロックの開始位置
        while start < a_num
            // マージする左ブロックと右ブロックの範囲を計算
            mid = start + block_size - 1 //左ブロック終端
            e = limit(start + 2 * block_size - 1,, a_num - 1) // 右ブロック終端
            if e <= mid : _break //右ブロックが存在しない
            j = mid + 1     // 右ブロックの開始インデックス
            
            leftsize = j - start

            // マージ処理
            k = 0 // temp配列のインデックス
			memcpy temp, a, leftsize << 2,, start << 2 //左半分を作業配列にコピー

            // 両ブロックを比較しながらマージ
			*loop_label
	            if b(temp(k)) <= b(a(j)) {
	                a(start) = temp(k)
	                k++
	                if k >= leftsize{
		                start = e + 1
		                _continue //マージ完了なので、内側のwhileの条件比較に向かう
		            }
	            } else {
	                a(start) = a(j)
	               	if j >= e{
		               	memcpy a, temp, leftsize -  k << 2, start + 1 << 2, k << 2
		               	start = e + 1
		               	_continue
		           }
	               j++
	            }
	            start++
            goto *loop_label
        wend
        block_size *= 2  // ブロックサイズを倍増
    wend
    return
#global

#module
#deffunc insertion_sort_range array a, int s, int e, array b
	// a配列[s]〜[e]を、bの優先度で昇順ソートする 
	if e <= s : return
	repeat e - s, s
		target = a(cnt + 1)
		priority = b(target)
		j = cnt
		while b(a(j)) > priority
			a(j + 1) = a(j)
			j--
			if j >= s: wend
		a(j + 1) = target
	loop
	return
#global
#endif